Блок 1: Запускаем среду и учимся ходить (3 сессии)

Старт: Docker + первая БД.
1 Урок.
Введение: зачем Oracle в 2025? (Кратко: надежность, экосистема, рынок труда).
Практика: Запуск Oracle XE в Docker (docker run -d -p 1521:1521 ...). Подключение через SQLcl/ SQL Developer. Первые команды (SELECT * FROM DUAL;).

Проектируем в SQL.
2 Урок.
Теория: Сущности, связи, ключи (ER-диаграмма на доске).
Практика: Пишем скрипт создания схемы для проекта "Библиотека" (таблицы books, readers, records). Запускаем в своих контейнерах.
3 Урок.
Живые данные: CRUD.
Теория: DML (INSERT, UPDATE, DELETE, SELECT). Фильтрация, сортировка.
Практика: Наполняем таблицы данными (скрипт). Интерактив: "Найдите самую старую книгу", "Добавьте себя как читателя".


Блок 2: Пишем логику и управляем доступом (5 сессий)
4 Урок. Сила JOIN и агрегации.
* Теория: INNER/LEFT JOIN, GROUP BY, агрегатные функции.
* Практика: Пишем запрос: "Сколько книг на руках у каждого читателя?" с выводом имени.
Представления (VIEW) для простоты.
Теория: Зачем нужны VIEW? Виртуализация и безопасность.
Практика: Создаем VIEW для сложного запроса из урока 4. Подключаемся к нему как к обычной таблице.

5 Урок.
Автоматизация через триггеры.
Теория: Триггеры на события (BEFORE INSERT, AFTER UPDATE).
Практика: Пишем триггер, который автоматически проставляет дату выдачи книги в records. Демо срабатывания.

6 Урок
Хранимая логика: процедуры и функции.
Теория: Отличие процедуры от функции. Блоки PL/SQL.
Практика: Создаем функцию calculate_fine(days INT), которая считает штраф за просрочку. Вызываем ее в запросе.

7 Урок.
Безопасность: пользователи и роли.
Теория: Принцип наименьших привилегий.
Практика: В своем контейнере создаем пользователя librarian, даем ему права только на SELECT к books и UPDATE к records. Пробуем подключиться под ним.


Блок 3: Интеграция и современный стек (3 сессии)

8 Урок.
Теория: Как понять, что тормозит? (Индексы, explain plan).
Практика: Пишем "тяжелый" запрос без индекса. Смотрим план. Создаем индекс и видим разницу. Работа с AWR (краткий обзор).

9 Урок. Работа с датами, временем и продвинутые функции.
Теория: Типы данных DATE, TIMESTAMP, INTERVAL. Функции для работы с датами (SYSDATE, EXTRACT, ADD_MONTHS, ROUND). Оконные функции (кратко, на примере ROW_NUMBER, RANK).

Практика (Проект "Библиотека"):

Добавляем в records поле return_date_planned (планируемая дата возврата) и return_date_actual (фактическая).

Обновляем данные.

Запрос 1: "Книги, просроченные более чем на 7 дней на текущую дату" (используем SYSDATE и арифметику с датами).
Запрос 2 (оконные функции): "Для каждого читателя выведите его последнюю взятую книгу" (используем ROW_NUMBER() OVER(PARTITION BY reader_id ORDER BY issue_date DESC)).

10 Урок. Автоматизация по расписанию: задания (DBMS_SCHEDULER).

Теория: Зачем нужны джобы в БД? Обзор DBMS_JOB и DBMS_SCHEDULER. Типы заданий (PL/SQL блок, stored procedure, внешний скрипт).

Практика (Проект "Библиотека"):

Создаем процедуру generate_monthly_report, которая формирует сводку (в новую таблицу reports или просто выводит в DBMS_OUTPUT): кол-во выданных книг, топ-5 популярных книг, список должников.

Создаем задание JOB_MONTHLY_REPORT, которое будет запускать эту процедуру в 00:00 первого числа каждого месяца.

Демо срабатывания: Чтобы не ждать месяц, меняем расписание на "через 2 минуты" и наблюдаем выполнение в логах (USER_SCHEDULER_JOB_LOG).

Блок 4: Сквозной проект "Умный учёт" (4 урока)
Идея: Усложняем проект "Библиотека" до системы "Умный учёт" с аудитом, резервным копированием и миграцией.

11 Урок. Аудит и безопасность данных.

Теория: Триггеры для аудита vs AUDIT команда. Создание таблицы аудита.

Практика:

Создаем таблицу books_audit (action, old_title, new_title, changed_by, change_date).

Создаем триггер trg_books_audit, который записывает в нее ВСЕ изменения (INSERT, UPDATE, DELETE) в таблицу books.

Проводим демо: обновляем название книги и смотрим запись в books_audit.

12 Урок. Транзакции, блокировки и целостность.
Теория: ACID на практике. COMMIT, ROLLBACK, SAVEPOINT. Проблемы параллельного доступа (Lost Update, Dirty Read).
Практика:
Сценарий "Бронирование": Эмулируем двух пользователей, которые хотят взять одну и ту же последнюю книгу.
В первой сессии начинаем транзакцию, проверяем доступность (SELECT FOR UPDATE NOWAIT).
Во второй сессии пытаемся сделать то же самое — получаем ошибку.
В первой завершаем оформление и делаем COMMIT.
Показываем, как ROLLBACK откатывает "ошибочную выдачу".

13 Урок. Резервное копирование и миграция (на уровне Docker).
Теория: Физические и логические бекапы. Экспорт/импорт (expdp, impdp). Перенос данных.
Практика:
Экспорт: В контейнере делаем логический дамп схемы "Библиотека" с данными: expdp user/password schemas=library directory=DATA_PUMP_DIR dumpfile=library.dmp.
Миграция: Останавливаем старый контейнер. Запускаем новый чистый контейнер Oracle.
Импорт: Копируем файл .dmp в новый контейнер и выполняем импорт: impdp user/password directory=DATA_PUMP_DIR dumpfile=library.dmp remap_schema=library:new_library.
Подключаемся к новой БД и проверяем, что все данные, триггеры, процедуры и джобы на месте.


14 Урок. Финальный кейс и защита проекта.

Формат: Вы — архитектор. Получаете задачу.
Кейс: "В библиотеку поступило 5000 новых книг (файл new_books.csv). Необходимо максимально быстро и безопасно обновить каталог, обновив существующие записи и добавив новые. При этом система должна продолжать работать."
Практика (Групповое решение):
Анализ: что нужно? (Внешняя таблица? SQL*Loader? MERGE? Пакетная обработка?)
Пишем скрипт (MERGE для обновления/добавления).
Обсуждаем, как обеспечить скорость (отключение индексов/триггеров на время загрузки, использование APPEND hint).
Обсуждаем безопасность (транзакция, точка сохранения, откат при ошибке).
Пишем финальный проверочный запрос, что все данные консистентны.

